# Tron Light Cycle (Polling-Based)

A **Tron-style light cycle game** implemented in **C** for a **Nios V softcore processor** running on an **FPGA VGA platform** (e.g. Intel DE10-Lite / CPUlator).

This version uses a **polling-based architecture** with a single main loop and software delay loops for timing. No hardware timers or interrupts are used.

The system allows a user to:
- Control a human player using push buttons
- Compete against an AI-controlled opponent
- Detect collisions in real time
- Track scores using seven-segment displays
- Render gameplay using VGA graphics

---

## Overview

This project implements a two-player Tron game using:
- Polling-based input handling
- Software delay–based timing control
- Direct memory-mapped VGA pixel buffer access
- Simple rule-based AI for the robot player
- Real-time collision detection and scoring logic

The design emphasizes **clarity, determinism, and simplicity**, serving as a baseline embedded implementation.

---

## System Architecture

- Single-threaded main loop
- Pushbutton input via polling
- Busy-wait delay for game speed control
- Direct register and memory-mapped I/O access
- No interrupt or MTIME usage

---

## Platform

- Nios V softcore CPU  
- VGA pixel buffer output  
- `address_map_niosv.h` memory map  
- Compatible with CPUlator  

---

## Controls

- `KEY0` – Turn right  
- `KEY1` – Turn left  

The human player must avoid:
- Screen boundaries
- Light trails
- Head-on and cross-over collisions

The first player to reach **9 points** wins the game.

---

## Functional Description

### Player State
Each player maintains:
- `(x, y)` position
- Direction (`UP`, `RIGHT`, `DOWN`, `LEFT`)
- Alive/dead state

Positions are updated once per game tick.

---

### Movement and Timing
- Both players move one pixel per tick
- Game speed is controlled using a software delay loop
- Timing accuracy depends on CPU execution speed

---

### Collision Detection
The game detects:
- Wall collisions
- Trail collisions
- Head-on collisions
- Cross-over collisions

On collision:
- The round ends
- Scores are updated
- The next round begins after a delay

---

### AI Behavior
The robot player:
- Attempts to move forward by default
- Checks one and two pixels ahead for obstacles
- Turns left or right if forward movement is blocked

---

## Graphics Output

- VGA output is generated by writing directly to the pixel buffer
- A white border defines the play area
- Player trails are drawn as solid-colored pixels

---

## Score Display

- Scores are displayed on the `HEX3–HEX0` seven-segment displays
- The game ends when either player reaches 9 points
- The screen fills with the winner’s color at game over

---

## Design Rationale

This version serves as a **baseline polling-based implementation**, focusing on:
- Straightforward control flow
- Readability and debuggability
- Fundamental embedded design concepts

A separate repository contains an **interrupt-driven, MTIME-based implementation** of the same game for comparison.

---

## Limitations

- CPU is fully occupied during gameplay
- Timing is not hardware-accurate
- Less scalable than interrupt-driven designs
